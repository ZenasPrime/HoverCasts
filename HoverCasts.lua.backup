-- HoverCasts.lua
-- Blizzard click-cast bindings at cursor while hovering Blizzard Party/Raid/Focus frames ONLY.
-- 3-column layout: Button | Ability | Mana (blue)
-- Header layout:
--   Line 1: "<Name> (Level X Race Spec Class)"  [left-justified, name class-colored]
--   Line 2 (just above table): "[<modifiers>]" [left-justified, highlighted text]
-- Cooldowns:
--   If cooldown remaining > 0: append "(X)" in light red AND grey out the spell name.
-- Snappy fade + smart placement (stays on-screen, farther from cursor).
-- Retail-safe: GetMouseFoci(), C_ClickBindings shapes, safe event registration.

local ADDON = ...
local f = CreateFrame("Frame")

local function HC_Print(msg)
    print(("HoverCasts: %s"):format(tostring(msg)))
end

C_Timer.After(0, function()
    HC_Print("Lua loaded. Type /hc for commands.")
end)

local CONFIG = {
    padding = 6,
    lineSpacing = 1,
    maxLines = 12,
    scale = 1.0,

    bgAlpha = 0.92,
    borderAlpha = 0.90,

    cursorOffsetX = 40,
    cursorOffsetY = -40,

    clampPadding = 10,
    pollInterval = 0.05,

    minActionX = 0,
    minActionGap = 4,
    manaGap = 8,

    fadeInTime = 0.04,
    fadeOutTime = 0.04,

    -- modifier text highlight
    modTextUseHighlight = true,
    modTextHighlightColor = { r = 1.00, g = 1.00, b = 1.00 }, -- white
    modTextGlow = false,

    -- cooldown styling
    cooldownParenHex = "ff8a8a", -- light red
    cooldownGreyHex  = "b0b0b0", -- grey for spell name when on cooldown

    showWhenNoUnit = false,
}

-- -----------------------------
-- Helpers
-- -----------------------------
local function CurrentModifierMask()
    local mask = 0
    if IsShiftKeyDown() then mask = mask + 3 end
    if IsControlKeyDown() then mask = mask + 12 end
    if IsAltKeyDown() then mask = mask + 48 end
    return mask
end

local function ModifierTextFromMask(mask)
    local t = {}
    if bit.band(mask, 3) ~= 0 then t[#t+1] = "Shift" end
    if bit.band(mask, 12) ~= 0 then t[#t+1] = "Ctrl" end
    if bit.band(mask, 48) ~= 0 then t[#t+1] = "Alt" end
    return table.concat(t, "+")
end

local function NiceButtonName(btn)
    if not btn then return "?" end
    if btn == "LeftButton" then return "Left" end
    if btn == "MiddleButton" then return "Middle" end
    if btn == "RightButton" then return "Right" end
    local n = btn:match("^Button(%d+)$")
    if n then return "Button " .. n end
    return btn
end

local function ColorText(txt, r, g, b)
    if not txt then return "" end
    return ("|cff%02x%02x%02x%s|r"):format(r * 255, g * 255, b * 255, txt)
end

local function ColorHexText(text, hex6)
    if not text or text == "" then return "" end
    return ("|cff%s%s|r"):format(hex6, text)
end

local function ClassColorForUnit(unit)
    if not unit then return 1, 1, 1 end
    local _, class = UnitClass(unit)
    local c = class and RAID_CLASS_COLORS and RAID_CLASS_COLORS[class]
    if c then return c.r, c.g, c.b end
    return 1, 1, 1
end

local function ResolveSpellName(spellID)
    if not spellID then return nil end
    if C_Spell and C_Spell.GetSpellName then
        return C_Spell.GetSpellName(spellID)
    end
    if C_Spell and C_Spell.GetSpellInfo then
        local info = C_Spell.GetSpellInfo(spellID)
        if type(info) == "table" then
            return info.name
        end
    end
    return nil
end

local function GetSpellManaCost(spellID)
    if not spellID or not C_Spell or not C_Spell.GetSpellPowerCost then
        return nil
    end
    local costs = C_Spell.GetSpellPowerCost(spellID)
    if not costs then return nil end
    for _, cost in ipairs(costs) do
        if cost.type == Enum.PowerType.Mana and cost.cost and cost.cost > 0 then
            return cost.cost
        end
    end
    return nil
end

local function GetSpellCooldownRemaining(spellID)
    if not spellID or not C_Spell or not C_Spell.GetSpellCooldown then
        return nil
    end

    local cd = C_Spell.GetSpellCooldown(spellID)
    if not cd or not cd.startTime or not cd.duration or cd.duration <= 0 then
        return nil
    end

    local remaining = (cd.startTime + cd.duration) - GetTime()
    if remaining and remaining > 0.05 then
        return remaining
    end
    return nil
end

local function FormatCooldown(sec)
    if not sec then return nil end
    if sec < 10 then
        return ("%.1fs"):format(sec)
    elseif sec < 60 then
        return ("%ds"):format(math.floor(sec + 0.5))
    else
        return ("%dm"):format(math.ceil(sec / 60))
    end
end

local function GetUnitSpecName(unit)
    if not unit or not UnitExists(unit) then return nil end
    if not UnitIsPlayer(unit) then return nil end
    if not UnitIsUnit(unit, "player") then return nil end

    if C_SpecializationInfo and C_SpecializationInfo.GetSpecialization then
        local specIndex = C_SpecializationInfo.GetSpecialization()
        if specIndex and C_SpecializationInfo.GetSpecializationInfo then
            local specID = C_SpecializationInfo.GetSpecializationInfo(specIndex)
            if specID and C_SpecializationInfo.GetSpecializationInfoByID then
                local _, specName = C_SpecializationInfo.GetSpecializationInfoByID(specID)
                if specName and specName ~= "" then
                    return specName
                end
            end
        end
    end

    if GetSpecialization and GetSpecializationInfo then
        local specIndex = GetSpecialization()
        if specIndex then
            local _, specName = GetSpecializationInfo(specIndex)
            if specName and specName ~= "" then
                return specName
            end
        end
    end

    return nil
end

local function GetUnitInfoText(unit)
    if not unit or not UnitExists(unit) then return "" end

    local level = UnitLevel(unit)
    if not level or level <= 0 then level = "??" end

    local race = UnitRace(unit) or ""
    local className = UnitClass(unit) or ""
    local spec = GetUnitSpecName(unit) or ""

    local parts = {}
    parts[#parts+1] = ("Level %s"):format(tostring(level))
    if race ~= "" then parts[#parts+1] = race end
    if spec ~= "" then parts[#parts+1] = spec end
    if className ~= "" then parts[#parts+1] = className end

    return table.concat(parts, " ")
end

-- Returns: actionName, manaCostOrNil, cooldownSecondsOrNil, isSpellBool
local function ResolveBindingActionName(b)
    if type(b) ~= "table" then return "Unknown", nil, nil, false end

    local actionID = b.actionID or b.spellID or b.macroID or b.action or b.id
    local t = b.type or b.actionType

    local enumSpell = Enum and Enum.ClickBindingType and Enum.ClickBindingType.Spell
    local enumMacro = Enum and Enum.ClickBindingType and Enum.ClickBindingType.Macro
    local enumInteract = Enum and Enum.ClickBindingType and Enum.ClickBindingType.Interact

    local isSpell =
        (t == "SPELL") or (t == "Spell") or (enumSpell and t == enumSpell) or (b.spellID ~= nil)

    local isMacro =
        (t == "MACRO") or (t == "Macro") or (enumMacro and t == enumMacro) or (b.macroID ~= nil)

    local isInteract =
        (t == "INTERACTION") or (t == "Interact") or (enumInteract and t == enumInteract)

    if isSpell and actionID then
        local name = ResolveSpellName(actionID) or "Unknown Spell"
        local mana = GetSpellManaCost(actionID)
        local cd = GetSpellCooldownRemaining(actionID)
        return name, mana, cd, true
    end

    if isMacro and actionID then
        local name = GetMacroInfo and GetMacroInfo(actionID) or "Macro"
        return name, nil, nil, false
    end

    if isInteract then
        return "Interact", nil, nil, false
    end

    return "Unknown", nil, nil, false
end

-- -----------------------------
-- Hover filtering (Blizzard Party / Raid / Focus ONLY)
-- -----------------------------
local function IsBlizzardUnitFrame(frame)
    if not frame then return false end
    local name = frame.GetName and frame:GetName() or nil
    if not name then return false end
    if name:match("^PartyFrame") then return true end
    if name:match("^CompactPartyFrame") then return true end
    if name:match("^CompactRaidFrame") then return true end
    if name:match("^CompactRaidGroup") then return true end
    if name:match("^FocusFrame") then return true end
    return false
end

local function ResolveUnitFromFrame(frame)
    if frame.unit and UnitExists(frame.unit) then
        return frame.unit
    end
    if frame.GetAttribute then
        local u = frame:GetAttribute("unit")
        if u and UnitExists(u) then
            return u
        end
    end
    if frame.unitFrame and frame.unitFrame.unit and UnitExists(frame.unitFrame.unit) then
        return frame.unitFrame.unit
    end
    return nil
end

local function GetHoveredUnit()
    local foci = (type(GetMouseFoci) == "function") and GetMouseFoci() or nil
    if not foci or #foci == 0 then return nil end

    for _, focus in ipairs(foci) do
        local cur = focus
        local depth = 0
        while cur and depth < 25 do
            local name = cur.GetName and cur:GetName() or nil
            if name and name:match("^HealBot_") then
                break
            end

            if IsBlizzardUnitFrame(cur) then
                local unit = ResolveUnitFromFrame(cur)
                if unit then return unit end
            end

            cur = cur.GetParent and cur:GetParent() or nil
            depth = depth + 1
        end
    end

    return nil
end

-- -----------------------------
-- UI Frame
-- -----------------------------
local tip = CreateFrame("Frame", "HoverCastsTip", UIParent, "BackdropTemplate")
tip:SetScale(CONFIG.scale)
tip:SetFrameStrata("TOOLTIP")
tip:SetClampedToScreen(true)
tip:SetAlpha(0)
tip:Hide()

tip:SetBackdrop({
    bgFile   = "Interface/Tooltips/UI-Tooltip-Background",
    edgeFile = "Interface/Tooltips/UI-Tooltip-Border",
    tile = true, tileSize = 16, edgeSize = 14,
    insets = { left = 3, right = 3, top = 3, bottom = 3 },
})
tip:SetBackdropColor(0.05, 0.05, 0.06, CONFIG.bgAlpha)
tip:SetBackdropBorderColor(0.35, 0.35, 0.38, CONFIG.borderAlpha)

tip.header = tip:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
tip.header:SetPoint("TOPLEFT", CONFIG.padding, -CONFIG.padding)
tip.header:SetJustifyH("LEFT")

tip.modLine = tip:CreateFontString(nil, "OVERLAY", "GameFontDisableSmall")
tip.modLine:SetPoint("TOPLEFT", tip.header, "BOTTOMLEFT", 0, -(CONFIG.lineSpacing + 3))
tip.modLine:SetJustifyH("LEFT")

tip.measureBtn  = tip:CreateFontString(nil, "OVERLAY", "GameFontDisableSmall")
tip.measureAct  = tip:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
tip.measureMana = tip:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
tip.measureBtn:Hide(); tip.measureAct:Hide(); tip.measureMana:Hide()

local function MeasureFS(fs, text)
    fs:SetText(text or "")
    if fs.GetUnboundedStringWidth then
        return fs:GetUnboundedStringWidth() or 0
    end
    return fs:GetStringWidth() or 0
end

tip.rows = {}
local ROW_H = 12

for i = 1, CONFIG.maxLines do
    local row = CreateFrame("Frame", nil, tip)
    row:SetHeight(ROW_H)

    if i == 1 then
        row:SetPoint("TOPLEFT", tip.modLine, "BOTTOMLEFT", -CONFIG.padding, -(CONFIG.lineSpacing + 4))
        row:SetPoint("TOPRIGHT", tip, "TOPRIGHT", 0, 0)
    else
        row:SetPoint("TOPLEFT", tip.rows[i-1], "BOTTOMLEFT", 0, -CONFIG.lineSpacing)
        row:SetPoint("TOPRIGHT", tip.rows[i-1], "BOTTOMRIGHT", 0, -CONFIG.lineSpacing)
    end

    row.button = row:CreateFontString(nil, "OVERLAY", "GameFontDisableSmall")
    row.button:SetPoint("LEFT", row, "LEFT", CONFIG.padding, 0)
    row.button:SetJustifyH("LEFT")

    row.mana = row:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    row.mana:SetPoint("RIGHT", row, "RIGHT", -CONFIG.padding, 0)
    row.mana:SetJustifyH("RIGHT")

    row.action = row:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
    row.action:SetJustifyH("LEFT")

    row:Hide()
    tip.rows[i] = row
end

-- -----------------------------
-- Position + Fade
-- -----------------------------
local function SetCursorAnchoredPosition(frame)
    local x, y = GetCursorPosition()
    local s = UIParent:GetEffectiveScale()
    x, y = x / s, y / s

    local w = frame:GetWidth() or 0
    local h = frame:GetHeight() or 0

    local pad = CONFIG.clampPadding or 10
    local uiW = UIParent:GetWidth()
    local uiH = UIParent:GetHeight()

    local placeRight = (x < uiW * 0.55)
    local placeDown  = (y > uiH * 0.45)

    local offX = CONFIG.cursorOffsetX or 40
    local offY = CONFIG.cursorOffsetY or -40

    local left = placeRight and (x + offX) or (x - offX - w)
    local top  = placeDown  and (y + offY) or (y - offY + h)

    if left < pad then left = pad end
    if (left + w + pad) > uiW then left = uiW - w - pad end

    if top > (uiH - pad) then top = uiH - pad end
    if (top - h) < pad then top = pad + h end

    frame:ClearAllPoints()
    frame:SetPoint("TOPLEFT", UIParent, "BOTTOMLEFT", left, top)
end

local function FadeIn(frame)
    frame:Show()
    if UIFrameFadeIn then
        UIFrameFadeIn(frame, CONFIG.fadeInTime or 0.04, frame:GetAlpha() or 0, 1)
    else
        frame:SetAlpha(1)
    end
end

local function FadeOut(frame)
    if UIFrameFadeOut then
        UIFrameFadeOut(frame, CONFIG.fadeOutTime or 0.04, frame:GetAlpha() or 1, 0)
    else
        frame:SetAlpha(0)
        frame:Hide()
    end
end

-- -----------------------------
-- Binding Cache
-- -----------------------------
local cachedBindings = nil

local function RefreshBindingCache()
    cachedBindings = {}
    if not C_ClickBindings or not C_ClickBindings.GetProfileInfo then return end

    local info = C_ClickBindings.GetProfileInfo()
    if type(info) ~= "table" then return end

    if type(info.bindings) == "table" then
        cachedBindings = info.bindings
        return
    end

    if #info > 0 then
        cachedBindings = info
        return
    end
end

-- -----------------------------
-- Render
-- -----------------------------
local Render
local _inRender = false

local BUTTON_ORDER = {
    LeftButton   = 1,
    MiddleButton = 2,
    RightButton  = 3,
    Button4      = 4,
    Button5      = 5,
}

local function SortEntries(a, b)
    local oa = BUTTON_ORDER[a._rawButton] or 99
    local ob = BUTTON_ORDER[b._rawButton] or 99
    if oa ~= ob then return oa < ob end
    return tostring(a.action) < tostring(b.action)
end

Render = function()
    if _inRender then return end
    _inRender = true

    local unit = GetHoveredUnit()
    if not unit and not CONFIG.showWhenNoUnit then
        FadeOut(tip)
        _inRender = false
        return
    end

    if not cachedBindings then RefreshBindingCache() end

    local mask = CurrentModifierMask()
    local modRaw = ModifierTextFromMask(mask)
    local modText = "[" .. (modRaw ~= "" and modRaw or "None") .. "]"

    if unit then
        local name = UnitName(unit) or "Unknown"
        local r, g, b = ClassColorForUnit(unit)
        local info = GetUnitInfoText(unit)
        if info ~= "" then
            tip.header:SetText(("%s (%s)"):format(ColorText(name, r, g, b), info))
        else
            tip.header:SetText(ColorText(name, r, g, b))
        end
    else
        tip.header:SetText("")
    end

    if CONFIG.modTextUseHighlight then
        local c = CONFIG.modTextHighlightColor
        tip.modLine:SetText(ColorText(modText, c.r, c.g, c.b))
        if tip.modLine.SetShadowColor then
            if CONFIG.modTextGlow then
                tip.modLine:SetShadowColor(c.r, c.g, c.b, 0.55)
                tip.modLine:SetShadowOffset(1, -1)
            else
                tip.modLine:SetShadowColor(0, 0, 0, 0)
                tip.modLine:SetShadowOffset(0, 0)
            end
        end
    else
        tip.modLine:SetText(modText)
        if tip.modLine.SetShadowColor then
            tip.modLine:SetShadowColor(0, 0, 0, 0)
            tip.modLine:SetShadowOffset(0, 0)
        end
    end

    local out = {}
    if cachedBindings and #cachedBindings > 0 then
        for _, bnd in ipairs(cachedBindings) do
            local bmods = bnd.modifiers or bnd.mods or 0
            if bmods == mask then
                local rawBtn = bnd.button or bnd.mouseButton or bnd.key
                local btn = NiceButtonName(rawBtn)
                local action, mana, cd, isSpell = ResolveBindingActionName(bnd)

                out[#out + 1] = {
                    btn = btn,
                    action = action,
                    mana = mana,
                    cd = cd,
                    isSpell = isSpell,
                    _rawButton = rawBtn
                }
            end
        end
    end

    table.sort(out, SortEntries)

    -- Clear rows SAFELY (do not touch out[i] here)
    for i = 1, CONFIG.maxLines do
        local row = tip.rows[i]
        row.button:SetText("")
        row.action:SetText("")
        row.mana:SetText("")
        row.action:ClearAllPoints()
        row:Hide()
    end

    local shownCount = 0
    if #out == 0 then
        local row = tip.rows[1]
        row.button:SetText("")
        row.action:SetText("No bindings for this modifier set.")
        row.mana:SetText("")
        row:Show()
        shownCount = 1
    else
        shownCount = math.min(#out, CONFIG.maxLines)
        for i = 1, shownCount do
            local row = tip.rows[i]
            local entry = out[i]

            row.button:SetText(entry.btn or "")

            local actionName = entry.action or ""
            local cdText = (entry.cd and entry.cd > 0) and FormatCooldown(entry.cd) or nil
            if entry.isSpell and cdText then
                actionName = ColorHexText(actionName, CONFIG.cooldownGreyHex)
            end

            local actionText = actionName
            if cdText then
                actionText = ("%s %s"):format(actionText, ColorHexText(("(%s)"):format(cdText), CONFIG.cooldownParenHex))
            end
            row.action:SetText(actionText)

            if entry.mana then
                row.mana:SetText(("|cff4da6ff%d mana|r"):format(entry.mana))
            else
                row.mana:SetText("")
            end

            row:Show()
        end
    end

    -- Measure columns (safe even when out is empty but we show "No bindings..." row)
    local maxBtnW, maxActionW, maxManaW = 0, 0, 0
    for i = 1, shownCount do
        local row = tip.rows[i]
        if row and row:IsShown() then
            maxBtnW = math.max(maxBtnW, MeasureFS(tip.measureBtn, row.button:GetText()))
            maxManaW = math.max(maxManaW, MeasureFS(tip.measureMana, row.mana:GetText()))

            local base, cdText = "", nil
            local entry = out[i]
            if entry then
                base = entry.action or ""
                cdText = (entry.cd and entry.cd > 0) and FormatCooldown(entry.cd) or nil
            else
                base = row.action:GetText() or ""
            end

            local measured = base
            if cdText then measured = ("%s (%s)"):format(base, cdText) end
            maxActionW = math.max(maxActionW, MeasureFS(tip.measureAct, measured))
        end
    end

    local pad = CONFIG.padding or 6
    local actionX = pad + maxBtnW + (CONFIG.minActionGap or 4)
    if actionX < (CONFIG.minActionX or 0) then actionX = CONFIG.minActionX or 0 end

    local headerW = MeasureFS(tip.measureAct, tip.header:GetText()) + pad * 2
    local modW = MeasureFS(tip.measureAct, modText) + pad * 2
    local totalW = pad + maxBtnW + (CONFIG.minActionGap or 4) + maxActionW + (CONFIG.manaGap or 8) + maxManaW + pad
    local width = math.max(totalW, headerW, modW)

    local height = pad
        + (tip.header:GetStringHeight() or 0)
        + (CONFIG.lineSpacing + 3)
        + (tip.modLine:GetStringHeight() or 0)
        + (CONFIG.lineSpacing + 6)

    for i = 1, shownCount do
        local row = tip.rows[i]
        if row and row:IsShown() then
            height = height + row:GetHeight() + (CONFIG.lineSpacing or 1)
        end
    end
    height = height + pad

    tip:SetSize(width, height)

    local inset = pad + (CONFIG.manaGap or 8) + maxManaW
    for i = 1, shownCount do
        local row = tip.rows[i]
        if row and row:IsShown() then
            row.action:ClearAllPoints()
            row.action:SetPoint("LEFT", row, "LEFT", actionX, 0)
            row.action:SetPoint("RIGHT", row, "RIGHT", -inset, 0)
        end
    end

    SetCursorAnchoredPosition(tip)
    FadeIn(tip)

    _inRender = false
end

-- -----------------------------
-- OnUpdate
-- -----------------------------
do
    local accum = 0
    tip:SetScript("OnUpdate", function(_, dt)
        if not tip:IsShown() then return end
        SetCursorAnchoredPosition(tip)

        accum = accum + dt
        if accum >= CONFIG.pollInterval then
            accum = 0
            Render()
        end

        if tip:GetAlpha() <= 0.01 then
            tip:Hide()
        end
    end)
end

-- -----------------------------
-- Events
-- -----------------------------
local function SafeRegisterEvent(frame, evt)
    pcall(frame.RegisterEvent, frame, evt)
end

SafeRegisterEvent(f, "PLAYER_LOGIN")
SafeRegisterEvent(f, "UPDATE_MOUSEOVER_UNIT")
SafeRegisterEvent(f, "MODIFIER_STATE_CHANGED")
SafeRegisterEvent(f, "CURSOR_CHANGED")

f:SetScript("OnEvent", function(_, event)
    if event == "PLAYER_LOGIN" then
        RefreshBindingCache()
        HC_Print("PLAYER_LOGIN. /hc for commands.")
        Render()
        return
    end

    if event == "UPDATE_MOUSEOVER_UNIT"
        or event == "MODIFIER_STATE_CHANGED"
        or event == "CURSOR_CHANGED" then
        Render()
        return
    end
end)

-- -----------------------------
-- Slash commands
-- -----------------------------
SLASH_HOVERCASTS1 = "/hc"
SLASH_HOVERCASTS2 = "/hovercasts"
SLASH_HOVERCLICKCASTS1 = "/hcc" -- backward-compatible alias

SlashCmdList.HOVERCASTS = function(msg)
    msg = (msg or ""):lower():gsub("^%s+", ""):gsub("%s+$", "")

    if msg == "on" then
        CONFIG.showWhenNoUnit = true
        tip:Show()
        tip:SetAlpha(1)
        Render()
        HC_Print("Debug on (show even without unit).")
    elseif msg == "off" then
        tip:Hide()
        HC_Print("Hidden.")
    elseif msg == "refresh" then
        RefreshBindingCache()
        Render()
        HC_Print("Refreshed.")
    elseif msg == "strict" then
        CONFIG.showWhenNoUnit = false
        Render()
        HC_Print("Strict mode (only show on hovered unit).")
    else
        HC_Print("Commands: /hc on | off | refresh | strict")
    end
end

SlashCmdList.HOVERCLICKCASTS = SlashCmdList.HOVERCASTS
